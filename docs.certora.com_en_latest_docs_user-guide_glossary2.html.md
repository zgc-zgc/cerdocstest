<!DOCTYPE html><html class="writer-html5" lang="en" data-content_root="../../"><head>
  <meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glossary — Certora Prover Documentation 0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1">
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094">
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b">
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=098d337b">
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=87e54e7c">

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=837179f8"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html">
    <link rel="search" title="Search" href="../../search.html">
    <link rel="next" title="The Certora Verification Language" href="../cvl/index.html">
    <link rel="prev" title="Syntax Highlighting on GitHub" href="github_highlighting.html"> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">

          
          
          <a href="../../index.html" class="icon icon-home">
            Certora Prover Documentation
              <img src="../../_static/Certora_Logo_Black.svg" class="logo" alt="Logo" width="646" height="188">
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs">
    <input type="hidden" name="check_keywords" value="yes">
    <input type="hidden" name="area" value="default">
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current" aria-expanded="true">
<li class="toctree-l1 current" aria-expanded="true"><a class="reference internal" href="index.html"><button class="toctree-expand" title="Open/close menu"></button>Certora User’s Guide</a><ul class="" aria-expanded="false">
<li class="toctree-l2"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="install_evm_compiler.html">Installing an EVM compiler and VS Code Extension</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorials.html">Tutorial and Workshops</a></li>
<li class="toctree-l2"><a class="reference internal" href="running.html">Running the Certora Prover</a></li>
<li class="toctree-l2"><a class="reference internal" href="properties/index.html">Designing Good Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="satisfy.html">Producing Positive Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="invariants.html">Invariants</a></li>
<li class="toctree-l2"><a class="reference internal" href="parametric.html">Parametric rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ghosts.html">Tracking changes with ghosts and hooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="patterns/index.html">Specification Design Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="opcodes.html">Using Opcode Hooks</a></li>
<li class="toctree-l2"><a class="reference internal" href="multicontract/index.html">Working with Multiple Contracts</a></li>
<li class="toctree-l2"><a class="reference internal" href="out-of-resources/index.html">Managing Timeouts and Out of Memory Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="gaps.html">Understanding gaps between high and low level code</a></li>
<li class="toctree-l2"><a class="reference internal" href="checking.html">Checking Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">CI Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="github_highlighting.html">Syntax Highlighting on GitHub</a></li>
<li class="toctree-l2 current" aria-expanded="true"><a class="reference internal current" href="#" aria-expanded="true">Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cvl/index.html">The Certora Verification Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prover/index.html">The Certora Prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sunbeam/index.html">Sunbeam: Verification for Soroban</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solana/index.html">The Certora Solana Prover</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gambit/index.html">Gambit: Mutation Generator for Solidity</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../equiv-check/index.html">The Certora Equivalence Checker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whitepaper/index.html">Certora Technology White Paper</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Certora Prover Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Certora User’s Guide</a></li>
      <li class="breadcrumb-item active">Glossary</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/docs/user-guide/glossary.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="glossary">
<span id="id1"></span><h1>Glossary<a class="headerlink" href="#glossary" title="Link to this heading"></a></h1>
<dl class="glossary">
<dt id="term-axiom">axiom<a class="headerlink" href="#term-axiom" title="Link to this term"></a></dt><dd><p>a statement accepted as true without proof.</p>
</dd>
<dt id="term-call-trace">call trace<a class="headerlink" href="#term-call-trace" title="Link to this term"></a></dt><dd><p>A call trace is the Prover’s visualization of either a
<a class="reference internal" href="#term-counterexample"><span class="xref std std-term">counterexample</span></a> or a <a class="reference internal" href="#term-witness-example"><span class="xref std std-term">witness example</span></a>.</p>
<p>A call trace illustrates a rule execution that leads up to the violation
of an <code class="docutils literal notranslate"><span class="pre">assert</span></code> statement or the fulfillment of a <code class="docutils literal notranslate"><span class="pre">satisfy</span></code> statement. The
trace is a sequence of commands in the rule (or in the contracts the rule
was calling into), starting at the beginning of the rule and ending with the
violated <code class="docutils literal notranslate"><span class="pre">assert</span></code> or fulfilled <code class="docutils literal notranslate"><span class="pre">satisfy</span></code> statement.
In addition to the commands, the call trace also does a best effort at
showing information about the program state at each point in the execution.
It contains information about the state of global variables at crucial points
as well as the values of call parameters, return values, and more.</p>
<p>If a call trace exists, it can be found in the “Call Trace” tab in the report
after selecting the corresponding (sub-)rule.</p>
</dd>
<dt id="term-CFG">CFG<a class="headerlink" href="#term-CFG" title="Link to this term"></a></dt><dt id="term-control-flow-graph">control flow graph<a class="headerlink" href="#term-control-flow-graph" title="Link to this term"></a></dt><dt id="term-control-flow-path">control flow path<a class="headerlink" href="#term-control-flow-path" title="Link to this term"></a></dt><dd><p>Control flow graphs (short: CFGs) are a program representation that
illustrates in which order the program’s instructions are processed during
program execution.
The nodes in a control flow graph represent single non-branching sequences
of commands. The edges in a control flow graph represent the possibility of
control passing from the last command of the source node to the first
command of the target node. For instance, an <code class="docutils literal notranslate"><span class="pre">if</span></code>-statement in the program
will lead to a branching, i.e., a node with two outgoing edges, in the
control flow graph.
A CVL rule can be seen as a program with some extra “assert” commands, thus
a rule has a CFG like regular programs.
The Certora Prover’s <a class="reference internal" href="../prover/diagnosis/index.html#tac-reports"><span class="std std-ref">TAC reports</span></a> contain a control flow graph
of the <a class="reference internal" href="#term-TAC"><span class="xref std std-term">TAC</span></a> intermediate representation of each given CVL rule.
The control flow paths are the paths from source to sink in a given CFG.
In general (and in practice) the number of control flow paths grows
exponentially with the size of the CFG. This is known as the path explosion
problem.
Further reading:
<a class="reference external" href="https://en.wikipedia.org/wiki/Control-flow_graph">Wikipedia: Control-flow graph</a>
<a class="reference external" href="https://en.wikipedia.org/wiki/Path_explosion">Wikipedia: Path explosion problem</a></p>
</dd>
<dt id="term-environment">environment<a class="headerlink" href="#term-environment" title="Link to this term"></a></dt><dd><p>The environment of a method call refers to the global variables that solidity
provides, including <code class="docutils literal notranslate"><span class="pre">msg</span></code>, <code class="docutils literal notranslate"><span class="pre">block</span></code>, and <code class="docutils literal notranslate"><span class="pre">tx</span></code>.  CVL represents these variables
in a structure of type <a class="reference internal" href="../cvl/types.html#env"><span class="std std-ref">env</span></a>.  The environment does <em>not</em> include
the contract state or the state of other contracts — these are referred to
as the <a class="reference internal" href="../cvl/types.html#storage-type"><span class="std std-ref">storage</span></a>.</p>
</dd>
<dt id="term-EVM">EVM<a class="headerlink" href="#term-EVM" title="Link to this term"></a></dt><dt id="term-Ethereum-Virtual-Machine">Ethereum Virtual Machine<a class="headerlink" href="#term-Ethereum-Virtual-Machine" title="Link to this term"></a></dt><dt id="term-EVM-bytecode">EVM bytecode<a class="headerlink" href="#term-EVM-bytecode" title="Link to this term"></a></dt><dd><p>EVM is short for Ethereum Virtual Machine.
EVM bytecode is one of the source languages that the Certora Prover internally
can take as input for verification. It is produced by the Solidity and Vyper
compilers, among others.
For details on what the EVM is and how it works, the following links provide
good entry points.
<a class="reference external" href="https://ethereum.org/en/developers/docs/evm/">Official documentation</a>,
<a class="reference external" href="https://en.wikipedia.org/wiki/Ethereum#Virtual_machine">Wikipedia</a></p>
</dd>
<dt id="term-EVM-memory">EVM memory<a class="headerlink" href="#term-EVM-memory" title="Link to this term"></a></dt><dt id="term-EVM-storage">EVM storage<a class="headerlink" href="#term-EVM-storage" title="Link to this term"></a></dt><dd><p>The <a class="reference internal" href="#term-EVM"><span class="xref std std-term">EVM</span></a> has two major concepts of memory, called <em>memory</em> and
<em>storage</em>. In brief, memory variables keep data only for the duration of a
single EVM transaction, while storage variables are stored persistently in
the Ethereum blockchain.
<a class="reference external" href="https://ethereum.org/en/developers/docs/smart-contracts/anatomy">Official documentation</a></p>
</dd>
<dt id="term-havoc">havoc<a class="headerlink" href="#term-havoc" title="Link to this term"></a></dt><dd><p>Havoc means that variables are assigned values chosen non-deterministically.
A havoc happens in two cases: the first, at the beginning of the rule all variables
“havoced”. The second, during certain events when the Certora Prover
should assume that some variables can change in an unknown way.
For example, an external function on an unknown contract
may have an arbitrary effect on the state of a third contract.  In this case,
we also say that the variable was “havoced”.  See <a class="reference internal" href="../cvl/methods.html#havoc-summary"><span class="std std-ref">Havoc summaries: HAVOC_ALL and HAVOC_ECF</span></a> and
<a class="reference internal" href="../cvl/statements.html#havoc-stmt"><span class="std std-ref">Havoc Statements</span></a> for more details.</p>
</dd>
<dt id="term-hyperproperty">hyperproperty<a class="headerlink" href="#term-hyperproperty" title="Link to this term"></a></dt><dd><p>A hyperproperty describes a relationship between two hypothetical sequences
of operations starting from the same initial state.  For example, a statement
like “two small deposits will have the same effect as one large deposit” is a
hyperproperty.  See <a class="reference internal" href="../cvl/types.html#storage-type"><span class="std std-ref">The storage type</span></a> for more details.</p>
</dd>
<dt id="term-invariant">invariant<a class="headerlink" href="#term-invariant" title="Link to this term"></a></dt><dd><p>An invariant (or representation invariant) is a property of the contract
state that is expected to hold between invocations of contract methods.  See
<a class="reference internal" href="../cvl/invariants.html#invariants"><span class="std std-ref">Invariants</span></a>.</p>
</dd>
<dt id="term-model">model<a class="headerlink" href="#term-model" title="Link to this term"></a></dt><dt id="term-example">example<a class="headerlink" href="#term-example" title="Link to this term"></a></dt><dt id="term-counterexample">counterexample<a class="headerlink" href="#term-counterexample" title="Link to this term"></a></dt><dt id="term-witness-example">witness example<a class="headerlink" href="#term-witness-example" title="Link to this term"></a></dt><dd><p>We use the terms “model” and “example” interchangeably.
In the context of a CVL rule, they refer to an assignment of values to all of
the CVL variables and contract storage that either violates an <code class="docutils literal notranslate"><span class="pre">assert</span></code>
statement or fulfills a <code class="docutils literal notranslate"><span class="pre">satisfy</span></code> statement.
In the <code class="docutils literal notranslate"><span class="pre">assert</span></code> case, we also call the model a “counterexample”. In the
<code class="docutils literal notranslate"><span class="pre">satisfy</span></code> case, we also call the model “witness example”.
See <a class="reference internal" href="../cvl/rules.html#rule-overview"><span class="std std-ref">Overview</span></a>.
In the context of <a class="reference internal" href="#term-SMT-solver"><span class="xref std std-term">SMT solver</span></a>s, a model is a valuation of the logical
constants and uninterpreted functions in the input formula that makes the formula
evaluate to <code class="docutils literal notranslate"><span class="pre">true</span></code>, also see <a class="reference internal" href="#term-SAT-result"><span class="xref std std-term">SAT result</span></a>.</p>
</dd>
<dt id="term-linear-arithmetic">linear arithmetic<a class="headerlink" href="#term-linear-arithmetic" title="Link to this term"></a></dt><dt id="term-nonlinear-arithmetic">nonlinear arithmetic<a class="headerlink" href="#term-nonlinear-arithmetic" title="Link to this term"></a></dt><dd><p>An arithmetic expression is called linear if it consists only of additions,
subtractions, and multiplications by constant. Division and modulo where the
second parameter is a constant are also linear arithmetic.
Examples for linear expressions are <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">y)</span></code>.
Every arithmetic expression that is not linear is nonlinear.
Examples for nonlinear expressions are <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">x</span></code>,
<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">/</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">^</span> <span class="pre">x</span></code>.</p>
</dd>
<dt id="term-overapproximation">overapproximation<a class="headerlink" href="#term-overapproximation" title="Link to this term"></a></dt><dt id="term-underapproximation">underapproximation<a class="headerlink" href="#term-underapproximation" title="Link to this term"></a></dt><dd><p>Sometimes it is useful to replace a complex piece of code with something
simpler that is easier to reason about.  If the approximation includes all of
the possible behaviors of the original code (and possibly others), it is
called an “overapproximation”; if it does not then it is called an
“underapproximation”.</p>
<p>Example: A <a class="reference internal" href="../cvl/methods.html#view-summary"><span class="std std-ref">NONDET</span></a> summary is
an overapproximation because every possible value that the original
implementation could return is considered by the Certora Prover, while an
<a class="reference internal" href="../cvl/methods.html#view-summary"><span class="std std-ref">ALWAYS</span></a> summary is an underapproximation if the
summarized method could return more than one value.</p>
<p>Proofs on overapproximated programs are <a class="reference internal" href="#term-sound"><span class="xref std std-term">sound</span></a>, but there may be
spurious <a class="reference internal" href="#term-counterexample"><span class="xref std std-term">counterexample</span></a>s caused by behavior that the original code
did not exhibit.  Underapproximations are more dangerous because a property
that is successfully verified on the underapproximation may not hold on the
approximated code.</p>
</dd>
<dt id="term-optimistic-assumptions">optimistic assumptions<a class="headerlink" href="#term-optimistic-assumptions" title="Link to this term"></a></dt><dt id="term-pessimistic-assertions">pessimistic assertions<a class="headerlink" href="#term-pessimistic-assertions" title="Link to this term"></a></dt><dd><p>Some input programs contain constructs that the Prover can only handle in
an approximative way. This approximation entails that the Prover will
disregard some specific parts of the programs behavior, like for example the
behavior induced by a loop being unrolled beyond a fixed number of times.
For each of these constructs the Prover provides a flag controlling whether
it should handle them optimistically or pessimistically. (See the links at the
end of this paragraph for examples of “optimistic” flags.)</p>
<p>In pessimistic mode (which is the default) <em>pessimistic assertions</em> are
inserted into the program that check whether there is any behavior that needs
to be approximated, for instance whether loops are present with bounds
exceeding <a class="reference internal" href="../prover/cli/options.html#loop-iter"><span class="std std-ref">loop_iter</span></a>. If this is the case, the rule will fail with
a corresponding message.</p>
<p>In optimistic mode, instead of the assertions, <em>optimistic assumptions</em> are
introduced in each of the places where an approximation happens. Each assumption
excludes the relevant behavior from checking for one occurrence of the problematic
construct, e.g., for each loop.</p>
<p>For a list of all “optimistic” settings see <a class="reference internal" href="../prover/cli/options.html#prover-cli-options"><span class="std std-ref">CLI Options</span></a>.
Examples include <a class="reference internal" href="../prover/cli/options.html#optimistic-hashing"><span class="std std-ref">optimistic_hashing</span></a>, <a class="reference internal" href="../prover/cli/options.html#optimistic-loop"><span class="std std-ref">optimistic_loop</span></a>,
<a class="reference internal" href="../prover/cli/options.html#optimistic-summary-recursion"><span class="std std-ref">optimistic_summary_recursion</span></a>, and more. Also see
<a class="reference internal" href="../prover/approx/index.html#prover-approximations"><span class="std std-ref">Prover Approximations</span></a> for more background on some of the
approximations.</p>
</dd>
<dt id="term-parametric-rule">parametric rule<a class="headerlink" href="#term-parametric-rule" title="Link to this term"></a></dt><dd><p>A parametric rule is a rule that calls an ambiguous method, either using a
method variable, or using an overloaded function name. The Certora Prover
will generate a separate report for each possible instantiation of the method.
See <a class="reference internal" href="../cvl/rules.html#parametric-rules"><span class="std std-ref">Parametric rules</span></a> for more information.</p>
</dd>
<dt id="term-quantifier">quantifier<a class="headerlink" href="#term-quantifier" title="Link to this term"></a></dt><dt id="term-quantified-expression">quantified expression<a class="headerlink" href="#term-quantified-expression" title="Link to this term"></a></dt><dd><p>The symbols <code class="docutils literal notranslate"><span class="pre">forall</span></code> and <code class="docutils literal notranslate"><span class="pre">exist</span></code> are sometimes referred to as <em>quantifiers</em>,
and expressions of the form <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">type</span> <span class="pre">v</span> <span class="pre">.</span> <span class="pre">e</span></code> and <code class="docutils literal notranslate"><span class="pre">exist</span> <span class="pre">type</span> <span class="pre">v</span> <span class="pre">.</span> <span class="pre">e</span></code> are
referred to as <em>quantified expressions</em>.  See <a class="reference internal" href="../cvl/expr.html#logic-exprs"><span class="std std-ref">Extended logical operations</span></a> for
details about quantifiers in CVL.</p>
</dd>
<dt id="term-receiveOrFallback">receiveOrFallback<a class="headerlink" href="#term-receiveOrFallback" title="Link to this term"></a></dt><dd><p>A special function we introduce in every contract to model the behavior of solidity
for calls with no data or that do not resolve to any contract function.
It will call the receive function if present for calls with no data, and otherwise the fallback function.
Shows up in the parametric rules or invariants, as well as in the call trace for such calls, written <code class="docutils literal notranslate"><span class="pre">&lt;receiveOrFallback&gt;()</span></code>.
See also <a class="reference external" href="https://docs.soliditylang.org/en/latest/contracts.html#fallback-function">Solidity Documentation</a>.</p>
</dd>
<dt id="term-sanity">sanity<a class="headerlink" href="#term-sanity" title="Link to this term"></a></dt><dd></dd>
<dt id="term-SAT">SAT<a class="headerlink" href="#term-SAT" title="Link to this term"></a></dt><dt id="term-UNSAT">UNSAT<a class="headerlink" href="#term-UNSAT" title="Link to this term"></a></dt><dt id="term-SAT-result">SAT result<a class="headerlink" href="#term-SAT-result" title="Link to this term"></a></dt><dt id="term-UNSAT-result">UNSAT result<a class="headerlink" href="#term-UNSAT-result" title="Link to this term"></a></dt><dd><p><em>SAT</em> and <em>UNSAT</em> are the results that an <a class="reference internal" href="#term-SMT-solver"><span class="xref std std-term">SMT solver</span></a> returns on a
successful run (i.e. not a timeout). SAT means that the input formula is
satisfiable and a <a class="reference internal" href="#term-model"><span class="xref std std-term">model</span></a> has been found. UNSAT means that the input
formula is unsatisfiable (and thus there is no model for it).
Within the Certora Prover, what SAT means depends on the type of rule
being checked: For an <code class="docutils literal notranslate"><span class="pre">assert</span></code> rule, SAT means the rule is violated and the
SMT model corresponds to a counterexample.
For a <code class="docutils literal notranslate"><span class="pre">satisfy</span></code> rule, SAT means the rule is not violated and the SMT model
corresponds to a witness example.
Conversely, UNSAT means that an <code class="docutils literal notranslate"><span class="pre">assert</span></code> is never violated or a <code class="docutils literal notranslate"><span class="pre">satisfy</span></code> never
fulfilled respectively.
See also <a class="reference internal" href="../cvl/rules.html#rule-overview"><span class="std std-ref">Overview</span></a>.</p>
</dd>
<dt id="term-scene">(scene)=<a class="headerlink" href="#term-scene" title="Link to this term"></a></dt><dt id="term-0">scene<a class="headerlink" href="#term-0" title="Link to this term"></a></dt><dd><p>The <em>scene</em> refers to the set of contract instances that the Certora Prover
knows about.</p>
</dd>
<dt id="term-SMT">SMT<a class="headerlink" href="#term-SMT" title="Link to this term"></a></dt><dt id="term-SMT-solver">SMT solver<a class="headerlink" href="#term-SMT-solver" title="Link to this term"></a></dt><dd><p>“SMT” is short for “Satisfiability Modulo Theories”. An SMT solver takes as
input a formula in predicate logic and returns whether the formula is
satisfiable (short “SAT”) or unsatisfiable (short: “UNSAT”). The “Modulo
Theory” part means that the solver assumes a meaning for certain symbols in
the formula. For instance the theory of integer arithmetic stipulates that the
symbols <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, etc. have their regular everyday mathematical
meaning.
When the formula is satisfiable, the SMT solver can also return a model for
the formula. I.e. an assignment of the formula’s variables that makes the
formula evaluate to “true”. For instance, on the formula “x &gt; 5 /\ x = y * y”,
a solver will return SAT, and produce any valuation where x is the square of
an integer and larger than 5, and y is the root of x.
Further reading: <a class="reference external" href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">Wikipedia</a></p>
</dd>
<dt id="term-sound">sound<a class="headerlink" href="#term-sound" title="Link to this term"></a></dt><dt id="term-unsound">unsound<a class="headerlink" href="#term-unsound" title="Link to this term"></a></dt><dd><p>Soundness means that any rule violations in the code being verified are
guaranteed to be reported by the Certora Prover.  Unsound approximations
such as loop unrolling or certain kinds of harnessing may cause real bugs
to be missed by the Prover, and should therefore be used with caution. See
<a class="reference internal" href="../prover/approx/index.html"><span class="doc">Prover Approximations</span></a> for more details.</p>
</dd>
<dt id="term-split">split<a class="headerlink" href="#term-split" title="Link to this term"></a></dt><dt id="term-split-leaf">split leaf<a class="headerlink" href="#term-split-leaf" title="Link to this term"></a></dt><dt id="term-split-leaves">split leaves<a class="headerlink" href="#term-split-leaves" title="Link to this term"></a></dt><dd><p>Control flow splitting is a technique to speed up verification by splitting the
program into smaller parts and verifying them separately. These smaller programs
are called splits. Splits that cannot be split further are called split leaves.
See <a class="reference internal" href="../prover/techniques/index.html#control-flow-splitting"><span class="std std-ref">Control flow splitting</span></a>.</p>
</dd>
<dt id="term-summary">summary<a class="headerlink" href="#term-summary" title="Link to this term"></a></dt><dt id="term-summarize">summarize<a class="headerlink" href="#term-summarize" title="Link to this term"></a></dt><dd><p>A method summary is a user-provided approximation of the behavior of a
contract method.  Summaries are useful if the implementation of a method is
not available or if the implementation is too complex for the Certora
Prover to analyze without timing out.  See <a class="reference internal" href="../cvl/methods.html"><span class="doc">The Methods Block</span></a> for
complete information on different types of method summaries.</p>
</dd>
<dt id="term-TAC">TAC<a class="headerlink" href="#term-TAC" title="Link to this term"></a></dt><dd><p>TAC (originally short for “three address code”) is an intermediate
representation
(<a class="reference external" href="https://en.wikipedia.org/wiki/Intermediate_representation">Wikipedia</a>)
used by the Certora Prover. TAC code is kept invisible to the
user most of the time, so its details are not in the scope of this
documentation. We provide a working understanding, which is helpful for some
advanced proving tasks, in the <a class="reference internal" href="../prover/diagnosis/index.html#tac-reports"><span class="std std-ref">TAC Reports</span></a> section.</p>
</dd>
<dt id="term-tautology">tautology<a class="headerlink" href="#term-tautology" title="Link to this term"></a></dt><dd><p>A tautology is a logical statement that is always true.</p>
</dd>
<dt id="term-vacuous">vacuous<a class="headerlink" href="#term-vacuous" title="Link to this term"></a></dt><dt id="term-vacuity">vacuity<a class="headerlink" href="#term-vacuity" title="Link to this term"></a></dt><dd><p>A logical statement is <em>vacuous</em> if it is technically true but only because
it doesn’t say anything.  For example, “every integer that is both greater
than 5 and less than 3 is a perfect square” is technically true, but only
because there are no numbers that are both greater than 5 and less than 3.</p>
<p>Similarly, a rule or assertion can pass, but only because the <code class="docutils literal notranslate"><span class="pre">require</span></code>
statements rule out all of the <a class="reference internal" href="#term-model"><span class="xref std std-term">model</span></a>s.  In this case, the rule
doesn’t say anything about the program being verified.
The <a class="reference internal" href="../prover/checking/sanity.html"><span class="doc">Rule Sanity Checks</span></a> help detect vacuous rules.</p>
</dd>
<dt id="term-verification-condition">verification condition<a class="headerlink" href="#term-verification-condition" title="Link to this term"></a></dt><dd><p>The Certora Prover works by translating a program an a specification into
a single logical formula that is satisfiable if and only if the program
violates the specification. This formula is called a
<em>verification condition</em>.
Usually, a run of the Certora Prover generates many verification conditions.
For instance a verification condition is generated for every
<a class="reference internal" href="#term-parametric-rule"><span class="xref std std-term">parametric rule</span></a>, and also for each of the sanity checks triggered by
<a class="reference internal" href="../prover/cli/options.html#rule-sanity"><span class="std std-ref">rule_sanity</span></a>.
See also <a class="reference internal" href="../whitepaper/index.html#white-paper"><span class="std std-ref">Certora Technology White Paper</span></a>, <a class="reference internal" href="index.html#user-guide"><span class="std std-ref">Certora User’s Guide</span></a>.</p>
</dd>
<dt id="term-wildcard">wildcard<a class="headerlink" href="#term-wildcard" title="Link to this term"></a></dt><dt id="term-exact">exact<a class="headerlink" href="#term-exact" title="Link to this term"></a></dt><dd><p>A methods block entry that explicitly uses <code class="docutils literal notranslate"><span class="pre">_</span></code> as a receiver is a <em>wildcard
entry</em>; all other entries are called <em>exact entries</em>.  See
<a class="reference internal" href="../cvl/methods.html"><span class="doc">The Methods Block</span></a>.</p>
</dd>
</dl>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="github_highlighting.html" class="btn btn-neutral float-left" title="Syntax Highlighting on GitHub" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../cvl/index.html" class="btn btn-neutral float-right" title="The Certora Verification Language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr>

  <div role="contentinfo">
    <p>© Copyright 2025, Certora, Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 


</body></html>